

# 逆向分析

逆向分析主要是将二进制机器码进行反汇编得到的汇编代码，在汇编代码的基础上进行功能分析。

* 静态分析：在不执行代码文件情况下，观察代码文件外部特征（文件类型，反汇编，反编译），
文件类型分析用于了解程序是用什么语言编写，用什么编译器编译的，以及程序是否被加密处理过。

* 动态分析：在程序文件执行过程中通过调试器来分析代码，获取内存的状态等。

（静态分析比较偏向于“总览全局” 而动态分析偏向于“细看局部” ）

X86 汇编代码有两种语法记法：Interl 和 AT&T 
                                            {
                                                IDA PRO,OLLYDBG,MASM 使用 intel 记法 ， 而 GCC 通常遵从AT&T记法 （intel记法占统治地位，也是如今常用的记法）

                                                intel汇编语言格式为 ： 操作项   目的操作数   源操作数
                                            }


# Shellcode

攻击者要执行的代码叫shellcode，只要启动了 /bin/sh 攻击者就能完全的控制计算机，
因此shellcode就是一段非常短小的机器语言代码，它的功能就是启动 /bin/sh


# MAGIC_ADDR

指专门通过一个地址获取shell的地址，一般位于system函数的实现代码中


# 栈

* 程序栈主要用于存储程序运行过程中局部信息，大小不固定，是动态增长的，栈内存一般可以根据 函数栈 来进行划分（不使用函数的程序比较少见）
不同函数栈之间是相互隔离的，从而实现有效的函数切换，函数栈上存储的信息包括：临时变量，函数的返回栈基址（BP），函数的返回地址（IP）

* 栈溢出指栈上的缓冲区被填入了过多数据，超出了边界从而导致栈上原有数据被覆盖（栈溢出是缓冲区溢出的一种类型）




# 栈 的特殊利用

1.libc信息泄露：可知main函数的栈底存放是 _libc_start_main_ret ，因此一旦能够使其返回地址泄露，就可以利用libc.so 文件 （或使用 libc_database）来计算libc基址以及system地址
2.多级指针，path指针，多用于格式化字符串：由于函数栈下面存放有环境变量，argv等指针，该指针通常可以用来泄露信息，另外这地址通常用于格式化字节串的漏洞
3.环境变量修改：环境变量指针参数会压在栈上，修改可以到达特定目的
4.通过libc泄露栈地址：栈地址通常都比较关键，很多时候都需要泄露出该地址，如果出现知道libc地址但不知道栈地址情况下，可根据libc中ENVIRON偏移来计算栈的偏移
5.往栈上写rop：对于不好布置情况，可以选择离当前函数栈较远的位置进行写入，然后通过返回到rop位置，如果可以再main函数栈底布置rop触发main函数返回条件，执行到rop

# 栈喷射 （stack-spray）

* 用于实现rop无法得到确定栈地址情况，通过预先在栈中布置大量重复性rop数据块，只要返回时栈位于其中一个数据块就能实现rop

# 线程栈

* 针对多线程程序来说，同一进程不同线程的栈都会布置在程序栈中，但是为了保证线程函数的正确执行，线程栈之间应相互隔离


# 堆 HEAP

* 主要是指用户动态申请的内存 （如 malloc，alloc，alloca，new 等函数）


# 格式化字符串漏洞

* 主要针对一些格式化函数（如 printf，sprintf，vsprintf 等），利用格式化字符串来指定串的格式
  通常，格式化函数是一种变长参数函数，参数需要根据栈参数传递进行释放 x86的参数全在栈上，x64参数从第4个开始放在栈上
  这些格式化函数遇到格式说明符的关键字符之后，会按照传参规则寻找 参数 来进行替换或修改，并不关心真实的传参情况

  



# 防御攻击的技术

* ASLR（地址空间布局随机化）是对栈，模块，动态分配的内存内存空间地址进行随机配置的机制。
【ASLR属于操作系统的功能】

* Exec-Shield 是一种通过 “限制内存的读写和执行权限”来防御攻击的机制
通常情况下我们不会在 栈空间里存放 可执行的 机器语言代码，因此我们可以把权限设为可读写，但是不可执行。
这样一来，就算把shellcode复制到栈，如果这些代码无法执行，那么就会产生Segmentation fault，导致程序停止运行。

* stackguard 是一种编译时在各函数入口\出口 插入用于检测栈数完整性的机器语言代码的方法 【属于编译器的安全机制】


# 绕开安全机制的技术

*使用libc中函数来进行攻击：Return-into-libc
Return-into-libc 是一种用库函数（lib）代替shellcode攻击的方法。
Return-into-libc 基本原理是通过调整参数和栈的配置，使得程序能够跳转到libc.so 中system函数及exec类函数，借此运行 /bin/sh 


# 利用未随机化模块内部汇编代码进行攻击：ROP （面向返回编程）

如果ASLR将加载的模块全部随机化的话，由于我们无法准确的模块地址（不知道 system 和 exec 的地址）攻击就会失败。
利用未随机化的那些模块内部的汇编代码，拼接出我们所需程序逻辑。


# 代码注入 （DLL注入）

* 用SetWindowsHookEx 劫持系统信息 
（SetWindowsHookEx/CallNextHookEx/UnhookWindowsHookEx）这些都是Windows的API，可以用于单线程或进程。
这些API用来劫持消息的，如果劫持其他进程窗口过程消息，那么需要 “在其他进程中” 加载我们的DLL。

* SetWindowsHookEx 可以调用时将DLL映射到其他进程中，如果我们将DLL路径配置在注册表AppLnit_DLLs 就可以在
系统启动时将任意DLL加载到其他进程中。
（WindowsXP 没有LoadAppInit_DLLs 这一项。Windows7 中多了一个叫 ：RequireSignedAppInit_DLLs, 这一项只允许经过签名的DLL）

*我们可以用 CreateRemoteThread 这个API函数在其他进程中创建线程，这个函数可以在新线程中运行 LoadLibrary 从而使得其他进程强制加载某个DLL。

# 注入函数

*我们用 CreateRemoteThread 调用了 LoadLibrary,不仅DLL，只要我们能够将任意函数（代码）事先复制到目标进程内部，就可以用 CreateRemoteThread 来运行它。

# Metaspoloit Framework

* Metaspoloit-Framework 是一个用于生成和运行攻击代码的框架，通常用于验证和调查软件漏洞。



# 干扰分析技术及破解方法

* 花指令：在原始的代码中插入一段无用或能够干扰反汇编引擎的代码，这段代码本身没有任何功能性作用，只是扰乱代码分析的手段

* 反调试：程序运行过程中探测是否处于被调试状态，如果发现在调试，则使无法正常运行（Linux下调试主要是通过 ptrace 实现的）

* 加壳：在二进制程序中植入一段代码，运行时候优先取得程序的控制权，代码在执行过程中对原始指令进行解密还原，之后再将控制权还给原始码，执行原来的代码

* 双进程保护：DEBUG-BLOCKER 是一种再调试模式下运行自身程序的方法，这种保护通常存在两个进程（调试器与被调试器）

* 虚拟机保护：指将代码翻译为机器和人都无法识别的一串伪代码字节流，在执行时再对这些伪代码进行逐一翻译，解释 逐步还原 为原始码并执行

* 脚本语言逆向：把解释型语言编译后变为字节码



# 信息泄露基本技巧
无论X86还是X64程序，后续参数都会存储在栈上，寻找参数时，是往栈底（地址变大）方向去寻找，而栈底方向依次存放当前函数，父函数以及调用者的函数信息，所以泄露信息时，一般除了泄露栈中本身存储数据之外
还会再栈上布置一些数据实现任意地址泄露，尤其对X64来说，寄存器的值 不好控制，想要实现任意地址泄露，则应更倾向于控制栈数据



# 整型漏洞
* 指发生在整型数据上的漏洞，传统整型溢出试图保护数据超过整型数据的宽度时发生的溢出，整型数据在计算机中存储有特定格式的，一般按字节进行存储
不同整型数据所需的字节也不同（该整型数据的宽度）如果数据所表达值大于该宽度，则会产生宽度溢出

# 符号转换
* 指有符号数与无符号数之间转换，两者主要区别在于最高位是否代表符号

-无符号数简单，所有位数都用来标识数据位
-有符号数最高位代表符号（0=正数 1=负数）

# 数据越界
* 对数组内存索引超出了数组的预设范围，从而可以访问到其他数据 （这种漏洞主要是由于检查不严格造成的）

# 逻辑漏洞

* 指程序逻辑上出现了问题，比如逻辑不严密或逻辑太复杂从而导致逻辑分支不能正常处理错误（通常这类漏洞出现在web或crypto里）

* 竞态条件漏洞：指多任务对同一资源进行访问时因访问资源的先后顺序不同产生产生冲突情况（通过竞态条件漏洞，可实现越权访问，资源篡改等操作）


# 加壳

* 可执行程序资源压缩，是保护文件的常用手段。加壳过的程序可以直接运行，但是不能查看源代码。要经过脱壳才可以查看源代码。
* 加壳是利用特殊的算法，对EXE、DLL文件里的资源进行压缩、加密。类似WINZIP 的效果，只不过这个压缩之后的文件，可以独立运行，解压过程完全隐蔽，都在内存中完成。
* 壳的类型通常分为压缩壳和加密壳两类。压缩壳的特点是减小软件体积大小，加密保护不是重点。加密壳种类比较多，不同的壳侧重点不同，一些壳单纯保护程序，另一些壳提供额外的功能，如提供注册机制、使用次数、时间限制等。



## OEP：(Original Entry Point)，程序的入口点。软件加壳一般隐藏了程序真实的OEP（或者用了假的OEP）， 我们需要寻找程序真正的OEP，才可以完成脱壳。
一般加壳程序在使用Ollydbg等动态调试工具时，会停在壳的预处理块。即处在对于程序原始代码块的解压或解密操作之前，在运行完程序自脱壳模块后，会停留在程序加壳之前的OEP位置，此时是dump程序的最佳时期。



## IAT：(Import Address Table)，导入地址表。由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL中。
当PE文件被装入内存的时候，Windows装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来（动态连接），这操作就需要导入表完成。其中导入地址表就指示函数实际地址。 多数加壳软件在运行时会重建导入地址表，因此获取加壳程序正确的导入地址表也是手动脱壳操作中的一个关键问题。




>------------

# 脱壳方法

* 单步跟踪法的原理就是通过Ollydbg的单步（F8）、单步进入（F7）和运行到（F4）功能，完整走过程序的自脱壳过程，跳过一些循环恢复代码的片段，并用单步进入确保程序不会略过OEP。这样可以在软件自动脱壳模块运行完毕后，到达OEP，并dump程序。

* ESP定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用pushad，在解压结束后，会将之前的寄存器值出栈，如使用popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的OEP位置。

* 内存镜像法是在加壳程序被加载时，通过OD的ALT+M快捷键，进入到程序虚拟内存区段。
内存镜像法的原理在于对于程序资源段和代码段下断点，一般程序自解压或者自解密时，会首先访问资源段获取所需资源，然后在自动脱壳完成后，转回程序代码段。这时候下内存一次性断点，程序就会停在OEP处。

* 所谓的一步到达OEP的脱壳方法，是根据所脱壳的特征，寻找其距离OEP最近的一处汇编指令，然后下int3断点，在程序走到OEP的时候dump程序。 

* 最后一次异常法的原理是，程序在自解压或自解密过程中，可能会触发无数次的异常。如果能定位到最后一次程序异常的位置，可能就会很接近自动脱壳完成位置。

* 模拟跟踪法的原理就是使用Ollydbg下条件断点，SFX相当于是一个自解压段，在自解压段结束时（eip的值转到代码段时）已经距离OEP很近，但是这种跟踪方法会比较耗时。

(参考：https://wooyun.js.org/drops/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%BD%AF%E4%BB%B6%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8.html)




>--------------
# Windows Library Files

## Kernel32.dll
* provides api for memory management,file operations,process (提供用于内存管理，文件操作，处理的api)

## User32.dll
* implements windows user component to provide graphical user interface such as menu bar,button,mouse,etc
(实现Windows用户组件以提供图形用户界面，例如菜单栏，按钮，鼠标等)

## GDI32.dll
* exports graphics device interface functions for drawing,text output,font management
(导出图形设备界面功能以进行绘图，文本输出，字体管理)

## Ntdll.dll
* interface to kernel for memory management,file operations,process,it's not normally used by windows applications directly
(用于内存管理，文件操作，进程的内核接口，Windows应用程序通常不直接使用它)

## Ws2_32.dll
* exports windows sockets apis (导出Windows套接字API)

## Wininet.dll
* provides high level network api such as httpopenrequest and ftpgetfile
(提供高级网络api，例如httpopenrequest和ftpgetfile)

## Advapi32.dll
* 对核心 Windows组件的访问，比如服务管理器和注册表

## Wsock32.dll 和 Ws2_32.dll
* 这两个是联网DLL，访问其中任一DLL的程序非常可能连接网络，或执行网络相关的任务

>----------------
#### 恶意代码编写者经常使用加壳或混淆技术，让他们文件更难以被检测或者分析。混淆程序是恶意代码编写者尝试去隐藏执行过程的代码。
>----------------


### .text   包含可执行代码
### .rdata  包含程序中全局可访问的只读数据
### .data   存储程序中可以访问的全局数据
### .idata  显示和存储导入函数信息，如果这个节不存在时，导入函数信息储存在.rdata节中
### .edata  有时会显示和储存导出函数信息，如果这个节不存在时，导数函数存储在.rdata中
### .pdata  只在64位可执行文件中存在，存储异常处理信息
### .rsrc   存储可执行文件所需资源
### .reloc  包含用来重定义库文件信息

>-------------------------------------

## cdecl
_cdecl是C和C ++程序的默认调用约定 (C Declaration的缩写)。因为堆栈是由调用方清理的，所以它可以执行vararg功能。该__cdecl调用约定创建大于可执行__stdcall，因为它要求每个函数调用堆栈包括清理代码。


## stdcall
__stdcall 是 StandardCall 的缩写，是C++的标准调用方式。stdcall 调用方式又被称为 Pascal 调用方式。在Microsoft C++系列的C/C++编译器中，使用 PASCAL 宏，WINAPI 宏和 CALLBACK 宏来指定函数的调用方式为 stdcall。

## fastcall
fastcall 按照名字上理解就可以知道，它是一种快速调用方式，因为它通过 CPU 寄存器来传递参数。此方式的函数的第一个和第二个DWORD参数通过ecx和edx传递，后面的参数从右向左的顺序压入栈。被调用函数清理堆栈

## thiscall
thiscall 调用方式是唯一一种不能显示指定的修饰符。它是C++类成员函数缺省的调用方式。由于成员函数调用还有一个this指针，因此必须用这种特殊的调用方式。

## naked call
是一种比较少见的调用方式，一般高级程序设计语言中不常见。函数的声明调用方式和实际调用方式必须一致，否则编译器会产生混乱。

>------------------------------------

About Ring （分级保护域）
参考：
https://zh.wikipedia.org/zh-hk/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F#/media/File:Priv_rings.svg 