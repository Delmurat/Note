 ################################# RE-逆向笔记 by Delmurat ##########################################


# CPU 寄存器

        * 指令寄存器 IR
        * 程序计数器 PC
        * 地址寄存器 AR
        * 数据寄存器 DR 
        * 累加寄存器 AC
        * 程序状态字寄存器 PSW


---------------------------------------------------------------------------------------
# 数据寄存器 【 EAX, EBX, ECX, EDX (Data Register) 】

数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。

--------------------------------------------------------------------------------------
# 指令寄存器

指令寄存器（Instruction Register，IR）用来保存当前正在执行的一条指令。

当执行一条指令时，首先把该指令从主存读取到数据寄存器中，然后再传送至指令寄存器。

-----------------------------------------------------------------------------------
# 指针寄存器 EBP, ESP (Pointer Register)

指针寄存器主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。

寄存器BP称为基址指针寄存器（Base Pointer）

寄存器SP称为堆栈指针寄存器（Stack Pointer）

# 变址寄存器 ESI, EDI (Index Register)

变址寄存器主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。 变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果


----------------------------------------------------------------------------------
# 程序计数器
程序计数器（Program Counter，PC）用来指出下一条指令在主存储器中的地址。

-------------------------------------------------------------------------------------
# 地址寄存器
地址寄存器（Address Register，AR）用来保存CPU当前所访问的主存单元的地址。

----------------------------------------------------------------------
# 累加寄存器

累加器（Accumulator，AC），是一个通用寄存器。

累加器的功能是：当运算器的算术逻辑单元ALU执行算术或逻辑运算时，为ALU提供一个工作区，可以为ALU暂时保存一个操作数或运算结果。

显然，运算器中至少要有一个累加寄存器。



----------------------------------------------------------------------
# 程序状态字寄存器

程序状态字（Program Status Word，PSW）用来表征当前运算的状态及程序的工作方式。

=========================================================================



-----------------------
># 常用指令
>     指令                   示列                         含义                       说明
>     MOV               MOV EAX ECX                   EAX=ECX               将ECX值存入EAX 
>     ADD               ADD EAX ECX                   EAX+=ECX              将EAX值加上ECX的值
>     SUB               SUB EAX ECX                   EAX-=ECX              将EAX值减去ECX的值
>     INC               INC EAX                       EAX++                 将EAX的值加1
>     DEC               DEC EAX                       EAX--                 将EAX的值减1
>     LEA               LEA EAX [ECX+4]               EAX=ECX+4             将ECX+4的值存入EAX
>     CMP               CMP EAX ECX            if(EAX==ECX)ZF=1 else ZF=0   对两个值比较根据结果标志（EAX与ECX相同 ZF=1 如不同则ZF=0）
>     TEST              TEST EAX EAX           if(EAX==0)ZF=1 else ZF=0     将值与0比较根据结果标志（EAX为0 则ZF=1 如不为0 则ZF=0）
>     JE(JZ)            JE 04001000            if(ZF==1)GOTO 04001000       如ZF为1，则跳转到04001000
>     JNE(JNZ)          JNE 04001000           if(ZF==0)GOTO 04001000       如ZF为0，则跳转到04001000
>     JMP               JMP 04001000           GOTO 04001000                跳转到04001000
>     CALL              CALLIstrcmpW                                        调用IstrcmpW
>     PUSH              PUSH 00000001                                       将00000001入栈
>     POP               POP EAX                                             出栈并将获取的值存入EAX



# 常用指令

移动                    MOV     在寄存器和RAM之间移动数据

推                      PUSH    将一个值压入堆栈

调用                    CALL    调用一个进程

返回                    RET     从进程返回

添加                    ADD     添加两个值

比较                    CMP     比较两个值

加载有效地址             LEA     将内存地址从源加载到目标

跳转                    JMP     跳到程序指定点

跳转不等于               JNE      如测试不等于0，则跳转

异步                    XOR     执行逻辑异步

转停                    HIT     停止指令执行


-----------------------

# 缓冲区溢出：

* 输入的数据超过了程序规定的内存范围，数据溢出导致程序发生异常。
- 当输入的数据超过内存范围的字节时，程序的行为将变得不可预测，这就称为了漏洞。

-----------------------

栈 是一种内存的使用方法（经常比喻成“直筒”或堆起来的牌子）栈不是物理上存在的东西，它也是普通的内存空间，只是像‘直筒’或推起来的盘子而已。







 # 86架构

* x86架構有8個通用寄存器（GPR）、6段寄存器、1個標誌寄存器和指令指針。 64位的x86有附加的寄存器

![x86](https://nieyong.github.io/wiki_cpu/CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-image/8086_reg.gif "x86")


# 寄存器组

> x86指令体系中寄存器如下

    * 通用寄存器：EAX,EBX,ECX,EDX,ESI,EBP,ESP,EDI
    * 指令指针寄存器（EIP）：指向当前要执行的指令
    * 状态标识寄存器（EFLAGS）：根据状态标识寄存器中状态的值控制程序的分支跳转
    * 段寄存器：CS,DS,SS,ES,FS,GS （当前操作系统中 CS,DS,SS,ES 的段寄存器基地址通常为0）
    * 特殊寄存器：用于设置硬件断点


* ESP和EBP用于管理栈
* EIP指向当前执行的指令



# intel汇编语言格式为 ： 操作项   目的操作数   源操作数

 1.数据传送类指令 （MOV DEST SRC）

 2.栈操作与函数调用  （入栈：PUSH 和 出栈：POP）

 call指令 将当前EIP保存到堆栈中，RET 指令读取堆栈，得到返回地址



>#
>       名称                  格式                       功能
>       入栈                PUSH SRC                ESP+=4;[ESP]=SRC
>       出栈                POP DEST                DEST=DEST;ESP_=4
>      调用函数             CALL FUNC               PUSH EIP; EIP=FUNC
>      函数返回             RET                     EIP=[ESP];ESP_=4



----------------------------------------
>#

>   算数，逻辑运算指令 （ADD SUB MUL DIV AND OR XOR)等算数逻辑运算

>   控制转移指令 

{
        CMP：对两个操作数执行减法操作，修改状态标识寄存器
        TEST：对两个操作数执行与操作，修改状态标识寄存器
        JMP：强制跳转指令
        JCC：条件跳转指令包括 JZ,JNZ

}

>   特殊指令：
{
        int3：对应字节码0xcc 主要用于设置软断点
        int8：Linux中32位系统调用指令
}





# CPU中的主要寄存器：有六类寄存器：

* 指令寄存器（IR）、
* 程序计数器（PC）、
* 地址寄存器（AR）、
* 数据寄存器（DR）、
* 累加寄存器（AC）、
* 程序状态字寄存器（PSW）


--------------------------------------------------

通用寄存器（GPR） - 32位命名約定
8個GPR是：

累加器寄存器（AX）。用在算術運算。
基址寄存器（BX）。作為一個指向數據的指針（在分段模式下，位於段寄存器DS）。
計數器寄存器（CX）。用於移位/循環指令和循環。
數據寄存器（DX）。用在算術運算和I/O操作。
堆棧指針寄存器（SP）。用於指向堆棧的頂部。
棧基址指針寄存器（BP）。用於指向堆棧的底部。
源變址寄存器（SI）。在流操作中用作源的一個指針。
目標索引寄存器（DI）。用作在流操作中指向目標的指針。
將它們以這樣的順序列出是有原因的：這個順序和堆棧操作中推入棧中的次序相同，我們以後會講到。

所有寄存器都可以在16位和32位模式下被訪問。在16位模式下，通過上面的列表中兩個字母的縮寫來確定該寄存器。在32位模式下，這兩個字母的縮寫名字前有「E」（extended，延伸）。例如，「EAX'是累加器寄存器作為一個32位的值。

類似地，在64位的版本，「E」被替換為「R」，所以在64位版本「EAX'被稱為'RAX'。


--------------------------------------------------------
># 
> 寄存器	   累加器  	計數器  	數據    	基址	  堆棧指針	   棧基址指針  	  源變址  	目標索引
> 64-bit	   RAX	        RCX	       RDX	       RBX	    RSP	           RBP	         RSI	        RDI
> 32-bit	   EAX		ECX	       EDX	       EBX          ESP		   EBP		 ESI		EDI
> 16-bit	   AX		CX	       DX	       BX	    SP		    BP		 SI		DI
> 8-bit	            AH AL       CH CL	      DH DL	       BH BL				

----------------------------------------------------------


# 堆栈指针寄存器sp
X86，ARM，MIPS下面都有堆栈指针寄存器。X86为通用地址指针寄存器中的堆栈指针SP，ARM为第14个通用寄存器r13作为堆栈指针寄存器sp，MIPS为第30个通用寄存器$29作为堆栈指针寄存器sp。sp中存放的是堆栈的栈顶地址。稍稍有点区别的是，X86由于地址产生方式的不同，堆栈指针sp（16位）和堆栈段寄存器（16位）共同产生堆栈栈顶地址（20位）。

X86的堆栈指针寄存器是一个特殊用途寄存器，因为该寄存器专门为堆栈设计，并且还有专门的指令pop和push来升降堆栈（入栈，出栈）。而ARM，MIPS的堆栈指针寄存器本质上是一个通用数据寄存器，和其他的通用数据寄存器的地位是一样的。堆栈的升降（入栈，出栈）也没有像X86中的专门的指令来操作，而是使用普通的算术指令（add，sub）来操作。


# 链接寄存器lr/返回地址寄存器ra
ARM的链接寄存器lr和MIPS的返回地址寄存器ra本质上是一样的，都是一个通用寄存器，被当做特殊用途，存放跳转时候的返回地址。这里的跳转是指需要返回的跳转指令，例如MIPS的jal，bal等。并不是指函数的跳转（应该叫做函数的调用更加准确）。

X86是没有专门的寄存器来存放跳转指令的返回地址的。那么，X86的跳转指令的返回是如何做到的呢？X86的跳转返回必须借助于堆栈，也就是说，在调用call指令跳转的时候，返回地址被自动保存到堆栈中了（对应RISC的，返回地址被自动保存到返回寄存器中），返回的时候，调用返回指令ret之后，返回地址被自动加载到指令指针寄存器ip中（对应的RISC中，就是使用jr $ra这种条状来返回，并没有向对应的返回指令。

# 程序计数寄存器
X86和ARM都有程序寄存器，X86的程序寄存器其实就是指令指针寄存器ip，而ARM的程序寄存器是一个通用寄存器r15。MIPS没有程序寄存器。

程序寄存器pc就是用来指示程序执行的位置，具体来说，就是当前执行指令的下一条指令的地址，告诉CPU要到哪里去取下一条指令。那么，为什么MIPS没有程序寄存器呢？MIPS又是如何知道下一条指令的地址呢？MIPS没有程序计数寄存器，其实是说MIPS的程序计数PC对程序员是不可见的。MIPS的CPU在运行的时候，当然也需要知道当前指令的位置，并且知道下一条指令要到哪个地址去取。当然，MIPS为了优化流水线，所以没有设计程序计数寄存器PC，另外，为了优化流水线，也遗留了加载延迟槽和跳转延迟槽等问题。


* 处理器的通用寄存器的设计，直接决定了逻辑处理的流程（例如出入栈，数据Load和store）以及算术处理的过程。而这些流程的确定，也就决定了汇编语言应该如何来组织。这也就要求编译器如何将更加高级的语言（例如C语言）转化成符合处理器架构的汇编语言。下面是摘自《ARM嵌入式系统开发-软件设计与优化》对RISC和CISC在编译器和处理器的关系。





# X64 架构


* 通用寄存器增加16个 （RAX,RBX,RDX,RCX,RBP,RDI,RSI,RSP,R8-R15)
* SYSCALL/SYSRET 是Linux x64 的系统调用方法